--------------------
Java Persistance API
--------------------

	1. Hello World JPA
	2. CRUD
	3. Primary key generation strategy
	4. More annotations:
	5. @SecondaryTable
	6. Composite Primary Keys
	7. @Enumerated
	8. Collection of Basic Types
	5. relationships Mapping 
		One to many
		one to one
		many to many 

	6. Inheritance strategies
	7. JPQL
	8. comparing Hibernate with JPA

starting mysql:
---------------
mysql -u root -p

1. Hello World JPA
-----------------------
	Steps in JPA
	--------------

	1.Create an JPA project 

	2.Create POJO annotate with annotations

	public class Book {
		private int id;
		private String isbn;
		private String title;
		private String author;
		private double price;
	}



	@Entity
	public class Book {
		@Id
		@GeneratedValue(strategy = GenerationType.AUTO)
		private int id;
		private String isbn;
		private String title;
		private String author;
		private double price;
	}



	3. updating persistance.xml
	-----------------------------------

<persistence xmlns="https://jakarta.ee/xml/ns/persistence"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="https://jakarta.ee/xml/ns/persistence 
             https://jakarta.ee/xml/ns/persistence/persistence_3_0.xsd"
	version="3.0">

	<persistence-unit name="HR_PU" transaction-type="RESOURCE_LOCAL">
	      <provider>org.hibernate.jpa.HibernatePersistenceProvider</provider>
		<class>com.demo.Product</class>
 			<properties>
	            <property name="javax.persistence.jdbc.driver" value="com.mysql.cj.jdbc.Driver"/>
	            <property name="javax.persistence.jdbc.url" value="jdbc:mysql://localhost:3306/ymsli26"/>
	            <property name="javax.persistence.jdbc.user" value="root"/>
	            <property name="javax.persistence.jdbc.password" value="root"/>
	                        <property name="hibernate.dialect"
                      value="org.hibernate.dialect.MySQL8Dialect"/>
	            <property name="hibernate.hbm2ddl.auto" value="create"/>
	            <property name = "hibernate.show_sql" value = "true" />
	             <property name="hibernate.format_sql" value="true"/>
        </properties>
		
	</persistence-unit>
</persistence>



	saving
	--------
		EntityManagerFactory emf = Persistence.createEntityManagerFactory("jpa");

		EntityManager em = emf.createEntityManager();

		Book book=new Book("123A", "head first", "katty", 370.5);

		EntityTransaction tx = em.getTransaction();

		try {
			tx.begin();

			em.persist(book);

			tx.commit();
			System.out.println("book is saved...");
		} catch (PersistenceException ex) {
			if (tx != null)
				tx.rollback();
		}

		em.close();
		emf.close();




	finding a book
	 ------------------------
	get vs load (hiberante )
	find	vs getReference()


		Book book=em.find(Book.class, 1);



	updating:
	----------
		//code to update a book
		em.getTransaction().begin();
		
		Book book=em.find(Book.class, 1);
		book.setAuthor("amit");

		em.merge(book);

		em.getTransaction().commit();
		
		em.close();
		emf.close();



	geetting list of all books:
	------------------------
		select b from Book b;
		select b from Book as b;
		from Book;


		List<Book> allBooks=em.createQuery("from Book").getResultList();
		for(Book b: allBooks)
			System.out.println(b.getTitle());


	deleting:
	-----------

		em.getTransaction().begin();
		
		Book book=em.find(Book.class, 1);
		em.remove(book);
		em.getTransaction().commit();






2. CURD application:
----------------------


	public interface BookDao {
		public List<Book> getAllBooks();
		public Book getBookById(int bookId);
		public Book addBook(Book book);
		public Book updateBook(Book book);
		public Book removeBook(int bookId);
	}


	
	
public class BookDaoImp implements BookDao {

	private EntityManagerFactory emf;
	
	
	public BookDaoImp(EntityManagerFactory emf) {
		this.emf = emf;
	}

	@Override
	public List<Book> getAllBooks() {
		EntityManager em=emf.createEntityManager();
		List<Book> allBooks=em.createQuery("from Book").getResultList();
		return allBooks;
	}

	@Override
	public Book getBookById(int bookId) {
		EntityManager em=emf.createEntityManager();
		Book book=em.find(Book.class, bookId);
		return book;
	}

	@Override
	public Book addBook(Book book) {
		EntityManager em=emf.createEntityManager();
		em.getTransaction().begin();
		em.persist(book);
		em.flush();
		em.getTransaction().commit();
		em.close();
		return book;
	}

	@Override
	public Book updateBook(Book book) {
		return null;
	}

	@Override
	public Book removeBook(int bookId) {
		return null;
	}

}


SCL
-----
EntityManagerFactory emf=Persistence.
				createEntityManagerFactory("foo");

doGet(...,...){
	

}



3. Primary key genearation strategy
------------------------------------

	@GeneratedValue(strategy=
				AUTO (By default :let hibernate make decision)

				Identity (Hibernate use identity column)

				Sequence

				Table



	Example table generation strategy
	------------------------------------------


	@Id
	@TableGenerator	(name="bookst",table="bookktable",pkColumnName="bookkey",
			pkColumnValue="bookvalue",allocationSize=1)

	@GeneratedValue(strategy=GenerationType.TABLE,generator="bookst")
	@Column(name="book_id")





4. More annoations @Basic, @Transient @Temporal @Table @Column @Lob etc...
----------------------------------------------------------------------



Consider:


	@Entity
	public class Book {
		@Id
		@GeneratedValue(strategy = GenerationType.AUTO)
		private int id;
		private String isbn;
		private String title;
		private String author;
		private double price;
	}



	What if table name and field name is something else?
	----------------------------------------------------



	@Entity(name="book-entity")
	@Table(name="book-table")
	public class Book {
		@Id
		@GeneratedValue(strategy = GenerationType.AUTO)
		@Column(name="book_id", nullable=false)
		private int id;
		private String isbn;
		@Basic
		private String title;
		private String author;
		private double price;




		Note: annotations can be applied to getters



	Understanding more annotations: basics, transient, temporal, lob
	------------------------------

		@Temporal(TemporalType.DATE)
		private Date joinedDate;  //java.util

		@Transient
		private int discount;

	
		@Basic ?:
			used to add some properties to add to that field.
		  	You can work apply without it.

	       @Transient?
			You can not store static and transient data.






5. @SecondaryTable
-------------------------

@Entity
public class Address {
	@Id
	@GeneratedValue(strategy=GenerationType.AUTO)
	private int id;
	private String addressLine1;
	private String addressLine2;
	
	private String city;
	private String state;
	private String pin;
	
	private String country;


What is requirment ?



@Entity
public class Address {
	@Id
	@GeneratedValue(strategy=GenerationType.AUTO)
	private int id;

	//SHOULD MAP TO ADDRESS TABLE
	private String addressLine1;
	private String addressLine2;
	
	//SHOULD MAP TO CITY TABLE
	private String city;
	private String state;
	private String pin;
	
	//SHOULD MAP TO COUNTRY TABLE
	private String country;




Using @SecondaryTable annotation:
----------------------------------

	@Entity
	@SecondaryTables({
		@SecondaryTable(name="city"),
		@SecondaryTable(name="country")
	})
	public class Address {
		@Id
		@GeneratedValue(strategy=GenerationType.AUTO)
		private int id;
		private String addressLine1;
		private String addressLine2;
		
		@Column(table="city")
		private String city;
		@Column(table="city")
		private String state;
		@Column(table="city")
		private String pin;
		
		@Column(table="country")
		private String country;






6. Composite Primary Keys
------------------------

@Embeddable
public class NewsId {
	private String title;
	private String language;
	
}

@Entity
public class News {

	@EmbeddedId
	private NewsId id;
	private String content;
	
}







7.@Enumerated
--------------



@Entity
public class Book {
	@Id
	@GeneratedValue(strategy = GenerationType.AUTO)
	private int id;
	private String isbn;
	private String title;
	private String author;
	private double price;
	
	@Enumerated(EnumType.STRING)
	private BookType bookType;

	enum BookType {
		PHYSICS, CHEM, MATHS
	}





8. Collection of Basic Types
----------------------------
One book have many reviews ( of string data type)



@Entity
public class Book {
	@Id
	@GeneratedValue(strategy = GenerationType.AUTO)
	private int id;
	private String isbn;
	private String title;
	private String author;
	private double price;
	
	@ElementCollection(fetch=FetchType.LAZY)
	@CollectionTable(name="book_reviews")
	@Column(name="review")
	private List<String> reviews=new ArrayList<String>();
	





6. Mapping relationships: many to one, one to one, many to many etc
--------------------------------------------------------------------

Many-To-One Mapping
-----------------
	Consider:-

	target <------------------- source
	

		1			N
	Department ------<>---------Employee

	  

	What is the ERD rule: put PK from 1 side to N side

	ie Put PK of Department going to put as FK in Employee table


	So that Employee is source entity and Department is target entities.




	@Entity
	public class Employee {

		@Id
		@GeneratedValue
		private int empId;
		private String empName;

		@ManyToOne
		private Department department;



	@Entity
	public class Department {
		@Id
		@GeneratedValue
		private int deptId;
		private String detpName;
	
		@OneToMany(mappedBy="department")
		private Collection<Employee>employees=new ArrayList<Employee>();
	


	Now controlling more to it
	------------------------------------
	The PK of Department is put as FK in employee table with 
	
	strange name of department_deptId

	I want to have some other name
	-----------------------------
		deptId_fk  what to do?




	@Entity
	public class Employee {

		@Id
		@GeneratedValue
		private int empId;
		private String empName;

		@ManyToOne
		@JoinColumn(name="deptId_fk")
		private Department department;






one-to-one mapping
--------------------

	In a one-to-one mapping the owner can be
	 either the source entity or the target entity.


				1		1
			Employee<>----------Parking





	public class Parking {
	
		private int partingId;
		private String parkingLocation;

	
		private Employee employee;



	
	public class Employee {
	
		private int empId;
		private String empName;

	
		private Parking parking;






	Now apply annotations
	---------------------------------



	@Entity
	public class Parking {
		@Id
		@GeneratedValue
		private int partingId;
		private String parkingLocation;

		@OneToOne(mappedBy = "parking")
		private Employee employee;



	@Entity
	public class Employee {
		@Id
		@GeneratedValue
		private int empId;
		private String empName;

		@OneToOne
		private Parking parking;







Many-to-Many mapping
----------------------

	   N		      N
	Employee----<>----- Project




	Create POJO
	-------------

	public class Employee {
	
		private int empId;
		private String empName;
	
		private Collection<Project> projects = new ArrayList<Project>();





	public class Project {
	
		private int projectId;
		private String projectName;

		private Collection<Employee> employees = new ArrayList<Employee>();









	Apply annotations
	----------------
	@Entity
	public class Employee {
		@Id
		@GeneratedValue
		private int empId;
		private String empName;

		@ManyToMany
		private Collection<Project> projects = new ArrayList<Project>();




	@Entity
	public class Project {
		@Id
		@GeneratedValue
		private int projectId;
		private String projectName;

		@ManyToMany(mappedBy="projects")
		private Collection<Employee> employees = new ArrayList<Employee>();



	Note:
	----------

	3 tables is going to be created:

		Employee 

		Project 

		employee_project (join table)
		--------------------------
			employees_empId
			projects_projectId


		Want more control:




	@Entity
	public class Employee {
		@Id
		@GeneratedValue
		private int empId;
		private String empName;

		@ManyToMany
		@JoinTable(name="emp_project", joinColumns={@JoinColumn(name="e_id" , referencedColumnName="empId")},
			inverseJoinColumns={
				@JoinColumn(name="proj_d", referencedColumnName="projectId")})
	
		private Collection<Project> projects = new ArrayList<Project>();












Some more exampels:





One to one
-----------
	Unidirectional:
		1		1
	Employee -------------> Parking

	@Entity
	class Employee {

	@Id
	private int id;

	private Parking parking;

	......
	......

	@OneToOne(cascade={CascadeType=PERSIST})
	public Parking getParking{

	}


	}


	@Entity
	class Parking{

	}


Cascade type:
-------------
	CascadeType.ALL	cascade all operations
		MERGE
		PERSIST
		REFRESH
		REMOVE





One to Many
-----------
	Unidirectional:

	
		1		N
	Company -------------> Employee


	@Entity
	class Company{

		private int id;

		private Collection<Employee> employees;

		.....
		........
		@OneToMany(Cascade={CascadeType.ALL}, fetch=FechType.EAGER)
		public Collection <Employee> getEmployees(){

		}

	}

	@Entity
	class Employee{



	}


Many to One
-----------
	Unidirectional:


	
		1		N
	Employee -------------> BusinessAddress


	@Entity
	class Employee{

	@Id
	private int id;

	.....
	private BusinessAddress businessAddress;

	@ManyToOne(Cascade={CascadeType.ALL})
	//apply on getter

	}


	@Entity
	class BusinessAddress{

	@Id
	private int id;
	}



Many to Many
-----------
	Unidirectional:

	Book <---------------> Author

	3 tables;
	----------

	Book ----Book_Author------- Author



	@Entity
	class Book{

	@Id
	private int id;
	private String bookName;

	private Collection<Author> authors=new ArrayList<Author>();

	@ManyToMany(Cascade={CasCadeType.ALL}, fetch=FetchType.Eager)
	@JoinTable(name="Book_Author")

	public Collection<Author>getAuthors(){
	}
	}


	@Entity
	class Author{

	@Id
	private int id;
	private String authorName;

	private Collection<Book> books=new ArrayList<Book>();

	}

	Now:
	------

	Author a1=new Author();
	...... a2=.........

	Book b1=new Book();
	... b2=...........

	b1.getAuthors().add(a1);
	b1.getAuthors().add(a2);


	.......
	em.persist(a1);
	em.persist(a2);


	for(Book b: ba.getAllBooks){

		Sysout(b.getBookName());

		for(AUthor temp:b.getAuthors())	
			Sysout(temp.getAuthorName());
	

	}


Understandign JPQUL
--------------------

	Extended version of EJB QueryLanguage

	Operate on classes and Object (entities ) in java workspace
	while SQl works on row/column in DB space

	JPQL statement can be extended only after they converted to 
	SQL

	JPQL --------> JPQL ------------------> SQL
		   Query Processor		Quaries


	Ex:

	Select e.employeeName form Employee e;


	
Query API
-----------

	Allow to create custom quaries to access a single or a collection
	of entities from the database

	Dynamic Quaries
	--------------
	Query q=em.createQuery("select e from Employee e");


	Named Query
	-----------
	Enhanced performance of execution of code
	
	Improve maintanance / reusability of code

	created / stored by using meta data annotaitons

	@Entiy
	@NamedQuery(name="findAllEmployees" query="select e from Employee e where e.employeeName LIKE : employeeName")


	public class Employee {




	}


	
	Query 	q=em.createNamedQuery("findAllEmployees");
		q.setParameter("employeeName",'raja');

		paginations
		----------
		q.setMaxResult(10);
		q.setFirstResult(3);

		List emp=q.getResultList();




Maven dependences:
------------------
	<properties>
		<maven.compiler.source>17</maven.compiler.source>
		<maven.compiler.target>17</maven.compiler.target>
		<hibernate.version>6.1.5.Final</hibernate.version>
	</properties>

	<dependencies>

		<dependency>
			<groupId>org.hibernate</groupId>
			<artifactId>hibernate-core</artifactId>
			<version>${hibernate.version}</version>
		</dependency>

		<!--xml processing -->
		<dependency>
			<groupId>jakarta.xml.bind</groupId>
			<artifactId>jakarta.xml.bind-api</artifactId>
			<version>3.0.0</version>
		</dependency>
		<!-- JAXB Implementation -->
		<dependency>
			<groupId>com.sun.xml.bind</groupId>
			<artifactId>jaxb-impl</artifactId>
			<version>3.0.0</version>
			<scope>runtime</scope>
		</dependency>

		<dependency>
			<groupId>com.mysql</groupId>
			<artifactId>mysql-connector-j</artifactId>
			<version>8.3.0</version>
		</dependency>

		<dependency>
			<groupId>jakarta.persistence</groupId>
			<artifactId>jakarta.persistence-api</artifactId>
			<version>3.1.0</version>
		</dependency>
	</dependencies>